\chapter{  Форматирование кода }

Любая синтаксически правильно написанная программа на многих языках программирования(в том числе и на С++) будет работать, даже если не уделять внимания на форматирование.

Пример плохо форматированной программы :

\begin{quote}
\begin{verbatim}
 
#include<iostream>

int main(){ std::cout<<"Hello world";return 0;}
 
\end{verbatim}
\end{quote}

Не смотря на то, что эта программа небольшая, и написана синтаксически правильно, её сложно читать. Если форматировать таким же стилем и более большую программу, то её сложнее будет читать, отлаживать и поддерживать.

В тоже время эту простую программу нетрудно отформатировать и привести к читабельному виду :

\begin{quote}
\begin{verbatim}
 
#include<iostream>

int main() { 
    std::cout << "Hello world";
    return 0;
    }
 
\end{verbatim}
\end{quote}

Когда один проект пишет много программистов с различными стилями, наступает т.н. "code hell", когда весь код программы невозможно отнести к одному единому стилю; тогда между программистами возникают споры по поводу правильного форматирования кода. Тогда, на общем совещании программистами решается какой единый стиль форматирования использовать в проекте. Создается документ с описанием стиля команды, и, если в команду приходит новый человек, то он обязательно должен ознакомиться с этим стилем и писать так, как пишут все. Иначе - его могут просто уволить. 
Также, т.к. все современные проекты содержаться в системах контроля версиями(cvs; svn,git,hg, etc.), в некоторых компаниях стоит фильтр на плохо форматированный код - невозможно будет добавить плохо отформатированный код в систему. 

У многих компаний этот стиль стандартизирован и его можно посмотреть в открытом доступе :
\begin{itemize}
\item Стиль написания библиотек Qt - \href{ http://qt.gitorious.org/qt/pages/QtCodingStyle}{ Qt - QtCodingStyle - Open wiki - Qt by Nokia}
\item Стиль написания в Google - \href{ http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml}{ Google C++ Style Guide}
\end{itemize}

Вот еще пример стилей форматирования C++ :
\begin{itemize}
\item \href{ http://geosoft.no/development/cppstyle.html}{ C++ Programming Style Guidelines}
\item \href{ http://www.possibility.com/Cpp/CppCodingStandard.html}{ C++ Coding Standard}
\item \href{ http://www.chris-lott.org/resources/cstyle/}{ C and C++ Style Guides}
\end{itemize}

Чаще всего понимание стиля форматирования вырабатывается с годами, поэтому нет ничего плохо в том, чтобы за основу брать какой-нибудь хорошо известный стиль форматирования.

\section{  Операции }

Всегда разделяйте операции( иногда, не только арифметические) пробелами(но не переусердствуйте).

Сравните :
\begin{quote}
\begin{verbatim}
 
int a=5+7/9*(6+8)-6;
 
\end{verbatim}
\end{quote}
А читабельнее этот код выглядил бы так :
\begin{quote}
\begin{verbatim}
 
int a = 5 + 7 / 9 * (6 + 8) - 6;
 
\end{verbatim}
\end{quote}

Вот еще пример хорошого форматирования ;
\begin{quote}
\begin{verbatim}
 
a += c + d;
a = (a + b) / (c * d);
 
\end{verbatim}
\end{quote}

\section{  Глобальные переменные }

Любая глобальная переменная должна начинаться с большой буквы :
\begin{quote}
\begin{verbatim}
 
const int N;
int Array[N][N];
 
\end{verbatim}
\end{quote}
Так вы не спутаете глобальные переменные с локальными.

\section{  Константы }

Именуйте ваши константы большими буквами, разделяя, при необходимости, составные слова подчеркиваниями :
Пример хороших констант :
\begin{quote}
\begin{verbatim}
 
const int N = 100;
const double PI = 3,14;
const double MAX_ITERATIONS = 100;
 
\end{verbatim}
\end{quote}

Иногда, константы именуют по первым большим буквам слов :
\begin{quote}
\begin{verbatim}
 
const double Pi = 3,14;
const double MaxIterations = 100;
 
\end{verbatim}
\end{quote}
Такое написание обладает следующим минусом : константы написанные таким образом легко спутать с глобалльными переменными.

\section{  Переменные итерации }

Общепринятые имена для переменных итерации - i, j, k. Очень в редких случаях не хватает этих трёх имен. Если у вас в программе не хватает этих трех имен, хорошенько подумайте над дизайном программы - возможно вы что-то делаете не так.

\section{  Цикл for }

Переменные итерации, если это цикл for, должны "жить" в нём и распространяться на его. Объяснить это очень просто - раз это переменные итерации, значит они должны итерировать только в цикле, нет необходимости их использовать вне цикла. Очень редко бывают случаи, когда нужно использовать переменные итерации вне области видимости цикла. 

Сравните, плохой код :
\begin{quote}
\begin{verbatim}
 
int i = 0;
for(; i < N; i++)
    std::cout << i;
 
\end{verbatim}
\end{quote}
Или, также плохой код :
\begin{quote}
\begin{verbatim}
 
int i = 0;
for(i = 0; i < N; i++)
    std::cout << i;
 
\end{verbatim}
\end{quote}

И хороший код :
\begin{quote}
\begin{verbatim}
 
for(int i = 0; i < N; i++)
    std::cout << i;
 
\end{verbatim}
\end{quote}
Все современные компиляторы(g++ 4.4 и старше, MSVC 8 и старше) распространяют действие переменной только на внутреннюю область видимости цикла. 
Таким образом, создаем и используем переменные итерации внутри цикла.

\section{  Числовые константы-литералы }

Если в вашей программе используются какие-то числовые константы, например размер массива, то создайте переменную-константу для этого числа.

Плохой код :
\begin{quote}
\begin{verbatim}
 
int ar[5] = {0, 1, 2, 3, 4};

for (int i = 0; i < 5; i++) {
    std::cout << ar[i];
}
 
\end{verbatim}
\end{quote}

Хороший код :
\begin{quote}
\begin{verbatim}
 
const int N = 5;
int ar[N] = {0, 1, 2, 3, 4};

for (int i = 0; i < N; i++) {
    std::cout << ar[i];
    }
 
\end{verbatim}
\end{quote}

\section{  Пустые строки }

Не пишите код программы подряд на каждой строке по операции, разделяйте по мере возможности код на группы областей пустыми строками :
\begin{quote}
\begin{verbatim}
 
int i = 0, j = 0, k = 0;

std::cout << i << j << k;
 
\end{verbatim}
\end{quote}
В этом небольшом куске кода мы разделили области создания переменных и их вывода на консоль. Разделив большой алгоритм на логические части, можно будет проще контролировать каждую часть - код становится приятнее и читабельнее. Но не злоупотребляйте расстановкой пустых строк.

\section{  Форматирование области видимости }

Области видимости или тела функций/классов/циклов/оператороа, разделяемые фигурными скобками должны быть оттабулированы, так будет видно где заканчивается действие той или иной области видимости.

Пример хорошо форматированного кода :

\begin{quote}
\begin{verbatim}
 
#include<iostream>

struct Point {
    int x;
    int y;
    };

int main() {     
    for (int i = 0; i < 5; i++) {
        std::cout << "Hello world" << std::endl;
        }
            
    return 0;
    }

 
\end{verbatim}
\end{quote}

\section{  Расстановка фигурных скобок }

Расстановка фигурных скобок во многих командах программистов бывает различной. Расстановка скобок зависит от того, как оформляются функции, сколько пробелов ставится для отступа тела функций и операторов и расположения фигурных скобок.

Подробнее о расстановке фигурных скобок и отступах можно прочитать здесь :
\begin{itemize}
\item \href{ http://en.wikipedia.org/wiki/Indent_style#Allman_style_.28bsd_in_Emacs.29}{ Indent style - Wikipedia}
\end{itemize}

\subsection{  Microsoft Visual Studio / Allman Style }

Вот пример расстановки фигурных скобок по умолчанию в Microsoft Visual Studio :
\begin{quote}
\begin{verbatim}
 
int main(int argc, _TCHAR* argv[])
{
    for (int i = 0; i < 10; i++) 
    {
        std::cout << i;
    }
    
    return 0;
}
 
\end{verbatim}
\end{quote}
До Visual Studio этот стиль был использован Эриком Оллманом в оформлении стандарта ANSI C, после чего стал называться стилем Оллмана.
Такой стиль очень похож на Horstmann style и GNU style.

\subsection{  GNU style }

GNU-стиль популярен из-за своего дополнительного переноса между типом возвращаемого параметра и названием функции :
\begin{quote}
\begin{verbatim}
 
static char *
concat (char *s1, char *s2)
{
  while (x == y)
    {
      something ();
      somethingelse ();
    }
  finalthing ();
}
 
\end{verbatim}
\end{quote}
По-видимому из-за влияния ФЯ Lisp Ричард Столлман популяризировал этот стиль.


\subsection{  Whitesmiths style }

Можно было бы использовать и такой распространенный стиль :
\begin{quote}
\begin{verbatim}
 
int main(int argc, _TCHAR* argv[])
    {
    for (int i = 0; i < 10; i++) 
        {
        std::cout << i;
        }
    
    return 0;
    }
 
\end{verbatim}
\end{quote}

\subsection{  K&R стиль }
Такой стиль был использован в Керниганом и Ритчи в их известной книге "Язык программирования C" :
\begin{quote}
\begin{verbatim}
 
int main(int argc, _TCHAR* argv[]) 
{
    for (int i = 0; i < 10; i++) {
        std::cout << i;
    }
    
    return 0;
}
 
\end{verbatim}
\end{quote}
Этот стиль расстановки скобок(особенно для вложенных конструкций) также называют египетскими скобками (egyptian brackets).
 
\subsection{  Banner C-style }
Мы будем использовать в основном этот стиль форматрования, на котором закрывающя фигурная скобка также имеет отступ как и тело цикла/функции/if-a и др :
\begin{quote}
\begin{verbatim}
 
int main(int argc, _TCHAR* argv[]) {
    for (int i = 0; i < 10; i++) {
        std::cout << i;
        }
    
    return 0;
    }
 
\end{verbatim}
\end{quote}
Заметьте, что //после закрывающей круглой скобки стоит пробел// и только потом открывающая фигурная скобка.
Этот стиль был выбран из-за своей удобности и простоты в офрмлении кода.

\section{  Табуляция vs Пробелы }

Для создания области видимо обычно нажимают <Tab>. Выбор того, как выглядит таб - это один символ табуляции или набор из 4 или 8 пробелов - сугубо индивидуальный. Этот выбор зависит от используемого редактора, т.к. не все редакторы поддерживают замену использования вместо табуляции 4х/8ми пробелов. Однако большинство современных редакторов(Eclipse, Code:Blocks, gedit) поддерживают замену символа табуляции на пробелы.
